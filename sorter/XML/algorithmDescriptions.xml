<algorithms>
    <algorithm>
        <name>Insertion Sort</name>
        <generalDescription><![CDATA[

        ]]></generalDescription>
        <runTimeAnalysis>

        </runTimeAnalysis>
        <codeExample><![CDATA[

        ]]></codeExample>
        <colorKey>
            <red>Node being compared to green node</red>
            <green>Node being "inserted"</green>
            <yellow>N/A</yellow>
        </colorKey>
    </algorithm>
    <algorithm>
        <name>Selection Sort</name>
        <generalDescription><![CDATA[

        ]]></generalDescription>
        <runTimeAnalysis>

        </runTimeAnalysis>
        <codeExample><![CDATA[

        ]]></codeExample>
        <colorKey>
            <red>The lowest node found thus far</red>
            <green>The node being compared to the red node</green>
            <yellow>N/A</yellow>
        </colorKey>
    </algorithm>
    <algorithm>
        <name>Bubble Sort</name>
        <generalDescription><![CDATA[

        ]]></generalDescription>
        <runTimeAnalysis>

        </runTimeAnalysis>
        <codeExample><![CDATA[

        ]]></codeExample>
        <colorKey>
            <red>The potentially "out-of-place" node</red>
            <green>Node being compared to the red node</green>
            <yellow>N/A</yellow>
        </colorKey>
    </algorithm>
    <algorithm>
        <name>Cocktail Sort</name>
        <generalDescription><![CDATA[

        ]]></generalDescription>
        <runTimeAnalysis>

        </runTimeAnalysis>
        <codeExample><![CDATA[

        ]]></codeExample>
        <colorKey>
            <red>Node being compared to the green node</red>
            <green>Node being compared to the red node</green>
            <yellow>N/A</yellow>
        </colorKey>
    </algorithm>
    <algorithm>
        <name>Quick Sort</name>
        <generalDescription><![CDATA[
            <p>One of the more complex sorting algorithms, Quick Sort is commonly used across a variety of platforms and purposes for it's incredible asymptotic efficiency in the average case. Furthermore, it is an in-place sorting algorithm, requiring little to no additional memory to perform efficiently. It is often implemented in a recursive fashion, yet, the call stack remains relatively small due to the expansion of only one partitition at a time. </p>
            <p>In essence, Quick Sort operates on the basis of a pivot and partitions. Using a (sometimes) random initial value as a pivot, Quick sort compares all values in the data set to the pivot, switching low values near the pivot with high values far from the pivot. When the high end node and the low end node intersect, this process of partitioning is complete. The pivot is swapped with the first node of the high side partition and the data array is essentially split into two equal pieces, the low and high partitions. This process is then repeated for each partition until partitions of one or fewer elements is created.</p>
            <p>Optimizations to create more efficient Quick Sorts often implement multithreading and/or the usage of other sorting algorithms below a certain threshold of elements, due to Quick Sort's lower efficiency at lower quantities of data. Furthermore, methods of choosing a more ideal pivot, such as the ninther or median of three methods, can further optimize Quick Sort's runtime. Advanced implementations of Quick Sort also take advantage of modern CPU caches and the potential of multiple pivots in order to further increase runtime efficiency. </p>
        ]]></generalDescription>
        <runTimeAnalysis>

        </runTimeAnalysis>
        <codeExample><![CDATA[

        ]]></codeExample>
        <colorKey>
            <red>The low-side node</red>
            <green>The high-side node</green>
            <yellow>The "pivot"</yellow>
        </colorKey>
    </algorithm>
    <algorithm>
        <name>Heap Sort</name>
        <generalDescription><![CDATA[

        ]]></generalDescription>
        <runTimeAnalysis>

        </runTimeAnalysis>
        <codeExample><![CDATA[

        ]]></codeExample>
        <colorKey>
            <red>Initial child node 1</red>
            <green>Initial child node 2</green>
            <yellow>The initial parent node</yellow>
        </colorKey>
    </algorithm>
</algorithms>
